<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        
    <style>
        html, body { 
            margin: 0; padding: 0; height: 100%; background-color: rgba(172, 155, 228, 0.115);
        }

        header { 
            width: 30%; height: 15; display:block; margin-left: auto; margin-right: auto;
            border: 4px solid skyblue; border-radius: 15px; padding: 3px;
        }

        nav {
            margin: 5px;
        }

        #Lnav { width: 10%; height: 100%;
            float: left; border: 3px solid skyblue; border-radius: 15px; 
        }

        #Rnav { width: 10%; height: 100%;
            float: right; border: 3px solid skyblue;  border-radius: 15px;
        }

        #box {
            width: 300px; height: 50px;
        }

        #pixel {
            font-size: 17px; padding: 5px;
        }

        #button1 {
            padding: 5px;
        }

        .button {
            border-radius: 15px;
            background-color: rgba(255, 255, 255);
            color: rgb(60, 136, 167);
            border: 1px solid skyblue;
        }

        .button:hover {
            color: white;
            background-color: skyblue;
        }

        #in_canvas {
            display: inline-block;
            margin: 20px;
            border-width: 5px;
            background-color: white;
            padding-top: 30px;
            padding-left: 15px;
            padding-right: 15px;
            padding-bottom: 30px;
        }

        #out_canvas {
            display: inline-block;
            margin: 20px;
            border-width: 5px;
            background-color: white;
            padding-top: 30px;
            padding-left: 15px;
            padding-right: 15px;
            padding-bottom: 30px;
        }

    </style>

    <script>
        // 전역 변수부
        let inCanvas, inCtx, inPaper; // 입력 영상 관련
        let outCanvas, outCtx, outPaper; // 출력 영상 관련
        let inImage, inH, inW; // 2차원 배열의 높이, 폭
        let outImage, outH, outW; // 2차원 배열의 높이, 폭
        let inFile;
        
        // 공통 함수부 : Open(), Display()...

        function init() {
            inCanvas = document.getElementById("inCanvas"); // 도화지
            inCtx = inCanvas.getContext("2d"); // 물감, 붓이 들은 통 
            outCanvas = document.getElementById("outCanvas"); // 도화지
            outCtx = outCanvas.getContext("2d"); // 물감, 붓이 들은 통 
        }

        function openImage() { // 선택한 jpg 파일을 읽어서, 메모리(3차원 배열, inImage)에 넣기..
            // inFile = document.getElementById("inFile").files[0]; // 선택한 jpg 파일 (01.jpg)
            let fileNum = document.getElementById('fileNum').value; // "55", "5"

            if(parseInt(fileNum) < 10) {
                fileNum = "0" + fileNum; // "05"

            }else {
                fileNum = fileNum;
            }

            // let inFname = "/images/" + fileNum + ".jpg"; // images/05.jpg
            let inFname = "/images/" + fileNum + ".jpg"; // images/05.jpg

            // 그림 파일 --> 이미지 객체
            let imageObject = new Image(); // 빈 이미지 객체 생성
            imageObject.src = inFname; // 파일이 이미지객체에 들어감.

            imageObject.onload = function() {
                // 중요! 입력 영상 크기 알아내기
                inH = imageObject.height;
                inW = imageObject.width;

                alert("inH = " + inH + " inW = " + inW);

                // 도화지 크기를 이미지 크기로 조절
                inCanvas.height = inH;
                inCanvas.width = inW;

                // 이미지 객체 --> 캔버스(화면)
                inCtx.drawImage(imageObject, 0, 0, inW, inH);

                // 메모리 할당 (3차원 배열)
                inImage = new Array(3); // 3면 (R, G, B)

                for(let m = 0 ; m < 3 ; m++) {
                    inImage[m] = new Array(inH);

                    for(let n = 0 ; n < inH ; n++) {
                        inImage[m][n] = new Array(inW);                   

                    }
                }

                // ** 중요! ** 캔버스의 이미지(화면) --> 배열의 칼라로 추출
                let colorBlob = inCtx.getImageData(0, 0, inW, inH);
                let R, G, B, Alpha;

                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        let pos = ((i * inW) + k) * 4; // 1픽셀 == 4byte
                        R = colorBlob.data[pos + 0];
                        G = colorBlob.data[pos + 1];
                        B = colorBlob.data[pos + 2];
                        Alpha = colorBlob.data[pos + 3];

                        inImage[0][i][k] = R;
                        inImage[1][i][k] = G;
                        inImage[2][i][k] = B;

                    }
                }
            }
        }

        

        function displayImage() {
            outCanvas.height = outH;
            outCanvas.width = outW;

            outPaper = outCtx.createImageData(outW, outH); // 이미지 크기의 빈 종이를 준비

            for(let i = 0 ; i < outH ; i++) {
                for(let k = 0 ; k < outW ; k++) {
                    let R = outImage[0][i][k];
                    let G = outImage[1][i][k];
                    let B = outImage[2][i][k];

                    outPaper.data[(i * outW + k) * 4 + 0] = R; // Red
                    outPaper.data[(i * outW + k) * 4 + 1] = G; // Green
                    outPaper.data[(i * outW + k) * 4 + 2] = B; // Blue
                    outPaper.data[(i * outW + k) * 4 + 3] = 255; // Alpha (투명도)
                
                }
            }
            outCtx.putImageData(outPaper, 0, 0);

        }

        // ** 영상 처리 함수부 ** 

        // 화소 점 처리 알고리즘

        function equalImage() { // 동일 영상 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면
            
            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            // ** 진짜 영상처리 알고리즘 **

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        outImage[rgb][i][k] = inImage[rgb][i][k];

                    }
                }
            }
            displayImage();

        }

        function reverseImage() { // 영상 반전 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++)
                    outImage[m][n] = new Array(outW);

            }

            // **** 진짜 영상처리 알고리즘 *****
            for (let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k= 0 ;  k < inW ; k++) {
                        if((startX <= k && k <= endX) && (startY <= i && i <= endY)) {
                            outImage[rgb][i][k] = 255 - inImage[rgb][i][k];

                        } else {
                            outImage[rgb][i][k] =  inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function grayImage() { // 그레이 스케일 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let i = 0 ; i < 3 ; i++) {
                outImage[i] = new Array(outH);

                for(let k = 0 ; k < outH ; k++) {
                    outImage[i][k] = new Array(outW);

                }
            }
            
            for(let i = 0 ; i < inH ; i++) {
                for(let k = 0 ; k < inW ; k++) {
                    if((startX <= k && k <= endX) && (startY <= i && i <= endY)) {
                        let sumvalue = inImage[0][i][k] + inImage[1][i][k] + inImage[2][i][k];
                        let avgvalue = sumvalue / 3;

                        outImage[0][i][k] = avgvalue;
                        outImage[1][i][k] = avgvalue;
                        outImage[2][i][k] = avgvalue;

                    } else {
                        outImage[0][i][k] = inImage[0][i][k];
                        outImage[1][i][k] = inImage[1][i][k];
                        outImage[2][i][k] = inImage[2][i][k];

                    }

                }
            }
            
            displayImage();
        }

        function bwImage() { // 흑백영상 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let i = 0 ; i < 3 ; i++) {
                outImage[i] = new Array(outH);

                for(let k = 0 ; k < outH ; k++) {
                    outImage[i][k] = new Array(outW);

                }
            }
            
            for(let i = 0 ; i < inH ; i++) {
                for(let k = 0 ; k < inW ; k++) {
                    if((startX <= k && k <= endX) && (startY <= i && i <= endY)) {
                        let sumvalue = inImage[0][i][k] + inImage[1][i][k] + inImage[2][i][k];
                        let avgvalue = sumvalue / 3;

                        if (avgvalue > 127) {
                            outImage[0][i][k] = 255;
                            outImage[1][i][k] = 255;
                            outImage[2][i][k] = 255;

                        }else {
                            outImage[0][i][k] = 0;
                            outImage[1][i][k] = 0;
                            outImage[2][i][k] = 0;

                        }
                    }else {
                        outImage[0][i][k] = inImage[0][i][k];
                        outImage[1][i][k] = inImage[1][i][k];
                        outImage[2][i][k] = inImage[2][i][k];

                    }
    
                }
            }
            displayImage();

        }

        function avgbwImage() { // 흑백(평균)

            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            let sum = 0;
            let avg = 0;
            let sumvalue = 0;
            let avgvalue = 0;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let i = 0 ; i < 3 ; i++) {
                outImage[i] = new Array(outH);

                for(let k = 0 ; k < outH ; k++) {
                    outImage[i][k] = new Array(outW);

                }
            }

            // 모든 값의 합
            for(let i = 0 ; i < inH ; i++) {
                for(let k = 0 ; k < inW ; k++) {
                    sumvalue = inImage[0][i][k] + inImage[1][i][k] + inImage[2][i][k];
                    avgvalue = sumvalue / 3;
                    sum += avgvalue;

                }
            }

            for(let i = 0 ; i < inH ; i++) {
                for(let k = 0 ; k < inW ; k++) {
                    if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                        sumvalue = inImage[0][i][k] + inImage[1][i][k] + inImage[2][i][k];
                        avgvalue = sumvalue / 3;
                        sum += avgvalue;

                    }
                }
            }

            avg = parseInt(sum / (outH * outW));

            for(let i = 0 ; i < inH ; i++) {
                for(let k = 0 ; k < inW ; k++) {
                    if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                        sumvalue = inImage[0][i][k] + inImage[1][i][k] + inImage[2][i][k];
                        avgvalue = sumvalue / 3;

                        if (avgvalue > avg) {
                            outImage[0][i][k] = 255;
                            outImage[1][i][k] = 255;
                            outImage[2][i][k] = 255;

                        }else {
                            outImage[0][i][k] = 0;
                            outImage[1][i][k] = 0;
                            outImage[2][i][k] = 0;

                        }

                    }else {
                        outImage[0][i][k] = inImage[0][i][k];
                        outImage[1][i][k] = inImage[1][i][k];
                        outImage[2][i][k] = inImage[2][i][k];

                    }
                }
            }
            displayImage();

        }

        function addImage() { // 밝기 조절
            let value = parseInt(prompt("숫자 :", " "));

            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면
            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX) && (startY <= i && i <= endY)) {
                            if(inImage[rgb][i][k] + value > 255) {
                                outImage[rgb][i][k] = 255;

                            }else if(inImage[rgb][i][k] + value < 0) {
                                outImage[rgb][i][k] = 0;

                            }else {
                                outImage[rgb][i][k] = inImage[rgb][i][k] + value;

                            }
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function mulImage() { // 곱하기
            let value = parseInt(prompt("숫자 :", " "));

            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            // ** 진짜 영상처리 알고리즘 **

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            if(inImage[rgb][i][k] * value > 255) {
                                outImage[rgb][i][k] = 255;

                            }else if(inImage[rgb][i][k] * value < 0) {
                                outImage[rgb][i][k] = 0;
                                
                            }else {
                                outImage[rgb][i][k] = inImage[rgb][i][k] * value;

                            }
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function divImage() { // 나누기
            let value = parseInt(prompt("숫자 :", " "));

            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            // ** 진짜 영상처리 알고리즘 **

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            if(inImage[rgb][i][k] / value > 255) {
                                outImage[rgb][i][k] = 255;
                                
                            }else if(inImage[rgb][i][k] / value < 0) {
                                outImage[rgb][i][k] = 0;
                                
                            }else {
                                outImage[rgb][i][k] = inImage[rgb][i][k] / value;

                            }     
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function gammaImage() { // 감마 처리
            let gamma1 = parseFloat(prompt("gamma 값 입력 : ", ""));

            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }
            
            // ** 진짜 영상처리 알고리즘 **

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            outImage[rgb][i][k] = 255 * Math.pow(inImage[rgb][i][k] / 255, gamma1); // 감마처리

                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function paracupImage() { // 파라볼라(컵) 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            // ** 진짜 영상처리 알고리즘 **
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            outImage[rgb][i][k] = 255.0 * Math.pow(((inImage[rgb][i][k] / 127.0) - 1), 2);

                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function paracapImage() { // 파라볼라(캡) 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면
            
            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            // ** 진짜 영상처리 알고리즘 **
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            outImage[rgb][i][k] = 255 - (255.0 * Math.pow(((inImage[rgb][i][k] / 127.0) - 1), 2));

                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }    

        // 기하학 처리 알고리즘

        function udImage() { // 상하 미러링    
            let y = 0
            
            for(let i = 0 ; i < inH ; i++) {
                for(let k = 0 ; k < inW ; k++) {
                    if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                        if(startX == 0 && startY == 0) {
                            outImage[0][i][k] = inImage[0][inH-i-1][k];
                            outImage[1][i][k] = inImage[1][inH-i-1][k];
                            outImage[2][i][k] = inImage[2][inH-i-1][k];

                        }else {      
                            outImage[0][i][k] = inImage[0][endY-y-1][k];
                            outImage[1][i][k] = inImage[1][endY-y-1][k];
                            outImage[2][i][k] = inImage[2][endY-y-1][k];

                        }
                    }else {
                        outImage[0][i][k] = inImage[0][i][k];
                        outImage[1][i][k] = inImage[1][i][k];
                        outImage[2][i][k] = inImage[2][i][k];

                    }
                }

                if((startY <= i && i <= endY)) {
                    y++

                }
            }
            displayImage();

        }

        function lrImage() { // 좌우 미러링
            let x = 0;

            // ** 진짜 영상처리 알고리즘 **
            for(let i = 0 ; i < inH ; i++) {
                x = 0;

                for(let k = 0 ; k < inW ; k++) {
                    if((startX <= k && k <= endX) && (startY <= i && i <= endY)) {
                        if(startX == 0 && startY == 0) {
                            outImage[0][i][k] = inImage[0][i][inW-k-1];
                            outImage[1][i][k] = inImage[1][i][inW-k-1];
                            outImage[2][i][k] = inImage[2][i][inW-k-1];

                        }else {
                            outImage[0][i][k] = inImage[0][i][endX-x-1];
                            outImage[1][i][k] = inImage[1][i][endX-x-1];
                            outImage[2][i][k] = inImage[2][i][endX-x-1];
 
                        }
                        if(k >= startX) {
                            x++   

                        }

                    }else {
                        outImage[0][i][k] = inImage[0][i][k];
                        outImage[1][i][k] = inImage[1][i][k];
                        outImage[2][i][k] = inImage[2][i][k];

                    }
                }

            }
            displayImage();

        }

        function zoomoutImage() { // 축소 알고리즘
            let scale = parseInt(prompt("축소 값 입력 :", "2"));
            
            if(startX == 0) {
                outH = parseInt(inH / scale);
                outW = parseInt(inW / scale);

                outImage = new Array(3);//3면 

                for(let m = 0 ; m < 3 ; m++) {
                    outImage[m] = new Array(outH);

                    for(let n = 0 ; n < outH ; n++) {
                        outImage[m][n] = new Array(outW);

                    }
                }

                for(let rgb = 0 ; rgb < 3 ; rgb++) {
                    for (let i = 0 ; i < inH ; i++) {
                        for (let k = 0 ; k < inW ; k++) {
                            outImage[rgb][parseInt(i / scale)][parseInt(k / scale)] = inImage[rgb][i][k];

                        }
                    }
                }

            }else {
                outH = inH;
                outW = inW;

                outImage = new Array(3);//3면 

                for(let m = 0 ; m < 3 ; m++) {
                    outImage[m] = new Array(outH);

                    for(let n = 0 ; n < outH ; n++) {
                        outImage[m][n] = new Array(outW);
                    }
                }

                for(let rgb = 0 ; rgb < 3 ; rgb++) {
                    let y = 0;

                    for (let i = 0 ; i < inH ; i++) {
                        let x = 0;

                        for (let k = 0 ; k < inW ; k++) {
                            if ((startX <= k && k <= endX) && (startY <= i && i <= endY)) {
                                outImage[rgb][parseInt(((y / 2) + ((endY - startY) / scale)))][parseInt(((x / 2) + ((endX - startX) / scale)))] = inImage[rgb][i][k];
                                x++;

                            }
                            else {
                                outImage[rgb][i][k] = inImage[rgb][i][k];

                            }
                        }   
                        if((startY <= i && i <= endY)) {
                            y++

                        }
                    }
                }
            }
            displayImage();

        }
        
        function zoominImage() { //확대 알고리즘 포워딩
            let scale = parseInt(prompt("확대 값 입력 :", "2"));
            
            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = parseInt(inH * scale);
            outW = parseInt(inW * scale);

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            outImage[rgb][parseInt(i * scale)][parseInt(k * scale)] = inImage[rgb][i][k];

                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function zoominImage2() { //확대 알고리즘 백워딩
            let scale = parseInt(prompt("확대 값 입력 :", "2"));
            
            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = parseInt(inH * scale);
            outW = parseInt(inW * scale);

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < outH ; i++) {
                    for(let k = 0 ; k < outW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            outImage[rgb][i][k] = inImage[rgb][parseInt(i / scale)][parseInt(k / scale)];

                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function moveImage() { // 이동 알고리즘
            let move_x = parseInt(prompt("x 값 입력 : ", ""));
            let move_y = parseInt(prompt("y 값 입력 : ", ""));

            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            // ** 진짜 영상처리 알고리즘 **
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX) && (startY <= i && i <= endY)) {
                            if((i + move_y) < outH && (k + move_x) < outW) {
                                outImage[rgb][i + move_x][k + move_y] = inImage[rgb][i][k];

                            }
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function rotateImage() { // 원하는 각도만큼 영상 회전시키기
            let value = parseInt(prompt("각도 입력 : ", " "));
            let radian = (value * Math.PI) / 180; // 라디안 값
            let centerH = inH / 2; // 이미지 중심좌표
            let centerW = inW / 2; // 이미지 중심좌표

            // (중요!) 출력 이미지의 크기가 결정 -> 알고리즘에 의존..
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            //  ?? rgb
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0; i < outH; i++) {
                    for (let k = 0; k < outW; k++) { // 회전 변환 행렬을 이용하여 회전하게 될 좌표 값 계산
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            let newH = parseInt((k - centerH) * Math.cos(radian) + (i - centerW) * Math.sin(radian) + centerH);
                            let newW = parseInt((i - centerW) * Math.cos(radian) - (k - centerH) * Math.sin(radian) + centerW);

                            if((0 <= newW && newW < inH) && (0 <= newH && newH < inW)) {
                                outImage[rgb][i][k] = inImage[rgb][newW][newH];

                            }else {
                                outImage[rgb][i][k] = 255;

                            }
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function ncrotateImage() { // 원하는 각도만큼 영상 회전시키기 (no cut)
            let value = parseInt(prompt("각도 입력 : ", " "));
            let radian = (value * Math.PI) / 180; // 라디안 값

            // w = h cos(90-radian) + w cos(radian)
            // h = h cos(radian) + w cos(90-radian)
            outH = parseInt(Math.abs(Math.cos(radian) * inH) + Math.abs(Math.cos(Math.PI / 2 - radian) * inW));
            outW = parseInt(Math.abs(Math.cos(radian) * inW) + Math.abs(Math.cos(Math.PI / 2 - radian) * inH));

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            let centerH = parseInt(outH / 2); // 이미지 중심좌표
            let centerW = parseInt(outW / 2); // 이미지 중심좌표

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0; i < outH; i++) {
                    for (let k = 0; k < outW; k++) { // 회전 변환 행렬을 이용하여 회전하게 될 좌표 값 계산
                        let newH = parseInt((k - centerH) * Math.cos(radian) + (i - centerW) * Math.sin(radian) + ((centerH / outW) * inW));
                        let newW = parseInt((i - centerW) * Math.cos(radian) - (k - centerH) * Math.sin(radian) + ((centerW / outH) * inH));

                        if((0 <= newW && newW < inH) && (0 <= newH && newH < inW)) {
                            outImage[rgb][i][k] = inImage[rgb][newW][newH];

                        }else {
                            outImage[rgb][i][k] = 255;

                        }
                    }
                }
            }
            displayImage();
            
        }

        // 화소 영역 처리 알고리즘

        function embossImage() {  //엠보싱 알고리즘
            outH = inH;
            outW = inW;

            // 배열 선언
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }

            }

            // 짱 중요한거 --> 마스크를 선택
            let mask = [[-1.0, 0.0, 0.0],
                        [0.0, 0.0, 0.0],
                        [0.0, 0.0, 1.0]];

            // 임시 입력 배열 (입력배열 + 2)
            let tmpInImage = new Array(3);

            for(let m = 0 ; m < 3 ; m++) {
                tmpInImage[m] = new Array(inH+2);

                for(let n = 0 ; n < inH + 2 ; n++) {
                    tmpInImage[m][n] = new Array(inW+2);

                }
            }
            

            // 임시 출력 배열 (출력배열과 크기 동일)
            let tmpOutImage = new Array(3);

            for(let m = 0 ; m < 3 ; m++) {
                tmpOutImage[m] = new Array(outH+2);

                for(let n = 0 ; n < inH + 2 ; n++) {
                    tmpOutImage[m][n] = new Array(outW+2);

                }
            }

            // 임시 입력 배열 초기화 ((127로)/평균값/인접값)
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH + 2 ; i++) {
                    for (let k = 0 ; k < inW + 2 ; k++) {
                        tmpInImage[rgb][i][k] = 127.0;

                    }
                }
            }

            // 입력 이미지 -> 임시 입력 이미지의 중간에 넣기
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k = 0 ; k < inW ; k++) {
                        tmpInImage[rgb][i+1][k+1] = inImage[rgb][i][k];

                    }
                }
            }
            // 영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k = 0 ; k < inW ; k++) {
                        // 한점 처리
                        let S = 0.0; // 9점을 곱해서 합한 결과
                        for(let m = 0 ; m < 3 ; m++) {
                            for(let n = 0 ; n < 3 ; n++) {
                                S += tmpInImage[rgb][i+m][k+n] * mask[m][n];

                            }  
                        }
                        tmpOutImage[rgb][i][k] = S;

                    }
                }
            }

            // 후처리 작업 (마스크의 합계가 0이면 ... 127 정도를 더해주기를 고려)
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < outH ; i++) {
                    for (let k = 0 ; k < outW ; k++) {
                        tmpOutImage[rgb][i][k] += 127.0;

                    }
                }
            }

            // 임시 출력 이미지 --> 원 출력 이미지
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < outH ; i++) {
                    for (let k = 0 ; k < outW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            if(tmpOutImage[rgb][i][k] > 255.0) {
                                outImage[rgb][i][k] = 255;

                            }else if(tmpOutImage[rgb][i][k] < 0.0) {
                                outImage[rgb][i][k] = 0;

                            }else {
                                outImage[rgb][i][k] = parseInt(tmpOutImage[rgb][i][k]);

                            }
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function sharpeImage() {  //샤프닝 알고리즘
            outH = inH;
            outW = inW;

            // 배열 선언
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++)
                    outImage[m][n] = new Array(outW);

            }

            // 짱 중요한거 --> 마스크를 선택
            let mask = [    [ -0.0 , -1.0 ,  0.0],
                            [ -1.0 ,  5.0 , -1.0],
                            [  0.0 , -1.0 ,  0.0]];

            // 임시 입력 배열 (입력배열 + 2)
            let tmpInImage = new Array(3);

            for(let m = 0 ; m < 3 ; m++) {
                tmpInImage[m] = new Array(inH+2);

                for(let n = 0 ; n < inH + 2 ; n++) {
                    tmpInImage[m][n] = new Array(inW+2);

                }
            }
    
            // 임시 출력 배열 (출력배열과 크기 동일)
            let tmpOutImage = new Array(3);
            for(let m = 0 ; m < 3 ; m++) {
                tmpOutImage[m] = new Array(outH+2);

                for(let n = 0 ; n < inH + 2 ; n++) {
                    tmpOutImage[m][n] = new Array(outW+2);

                }
            }

            // 임시 입력 배열 초기화 ((127로)/평균값/인접값)
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH + 2 ; i++) {
                    for (let k = 0 ; k < inW + 2 ; k++) {
                        tmpInImage[rgb][i][k] = 127.0;

                    }
                }
            }

            // 입력 이미지 -> 임시 입력 이미지의 중간에 넣기
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k = 0 ; k < inW ; k++) {
                        tmpInImage[rgb][i+1][k+1] = inImage[rgb][i][k];

                    }
                }
            }
            // 영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k = 0 ; k < inW ; k++) {
                        // 한점 처리
                        let S = 0.0; // 9점을 곱해서 합한 결과

                        for(let m = 0 ; m < 3 ; m++) {
                            for(let n = 0 ; n < 3 ; n++) {
                                S += tmpInImage[rgb][i+m][k+n] * mask[m][n];

                            }  
                        }
                        tmpOutImage[rgb][i][k] = S;

                    }
                }
            }

            // 임시 출력 이미지 --> 원 출력 이미지
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < outH ; i++) {
                    for (let k = 0 ; k < outW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            if(tmpOutImage[rgb][i][k] > 255.0) {
                                outImage[rgb][i][k] = 255;

                            }else if(tmpOutImage[rgb][i][k] < 0.0) {
                                outImage[rgb][i][k] = 0;

                            }else {
                                outImage[rgb][i][k] = parseInt(tmpOutImage[rgb][i][k]);

                            }
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function blurImage() {  //블러링 알고리즘
            outH = inH;
            outW = inW;

            // 배열 선언
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            // 짱 중요한거 --> 마스크를 선택
            let mask = [    [ 1.0/9 , 1.0/9 , 1.0/9],
                            [ 1.0/9 , 1.0/9 , 1.0/9],
                            [ 1.0/9 , 1.0/9 , 1.0/9]
                        ];

            // 임시 입력 배열 (입력배열 + 2)
            let tmpInImage = new Array(3);

            for(let m = 0 ; m < 3 ; m++) {
                tmpInImage[m] = new Array(inH+2);

                for(let n = 0 ; n < inH + 2 ; n++) {
                    tmpInImage[m][n] = new Array(inW+2);

                }
            }

            // 임시 출력 배열 (출력배열과 크기 동일)
            let tmpOutImage = new Array(3);

            for(let m = 0 ; m < 3 ; m++) {
                tmpOutImage[m] = new Array(outH+2);

                for(let n = 0 ; n < inH + 2 ; n++) {
                    tmpOutImage[m][n] = new Array(outW+2);

                }
            }

            // 임시 입력 배열 초기화 ((127로)/평균값/인접값)
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH + 2 ; i++) {
                    for (let k = 0 ; k < inW + 2 ; k++) {
                        tmpInImage[rgb][i][k] = 127.0;

                    }
                }
            }

            // 입력 이미지 -> 임시 입력 이미지의 중간에 넣기
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k = 0 ; k < inW ; k++) {
                        tmpInImage[rgb][i+1][k+1] = inImage[rgb][i][k];

                    }
                }
            }
            // 영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for(let rgb = 0 ; rgb < 3; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k = 0 ; k < inW ; k++) {
                        // 한점 처리
                        let S = 0.0; // 9점을 곱해서 합한 결과

                        for(let m = 0 ; m < 3 ; m++) {
                            for(let n = 0 ; n < 3 ; n++) {
                                S += tmpInImage[rgb][i+m][k+n] * mask[m][n];

                            }  
                        }
                        tmpOutImage[rgb][i][k] = S;

                    }
                }
            }

            // 임시 출력 이미지 --> 원 출력 이미지
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < outH ; i++) {
                    for (let k = 0 ; k < outW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            if(tmpOutImage[rgb][i][k] > 255.0) {
                                outImage[rgb][i][k] = 255;

                            }else if(tmpOutImage[rgb][i][k] < 0.0) {
                                outImage[rgb][i][k] = 0;

                            }else {
                                outImage[rgb][i][k] = parseInt(tmpOutImage[rgb][i][k]);

                            }
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function gaussianImage() { // 가우시안 알고리즘
            outH = inH;
            outW = inW;

            // 배열 선언
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++)
                    outImage[m][n] = new Array(outW);

            }

            // 짱 중요한거 --> 마스크를 선택
            let mask = [
                [1.0/16, 1.0/8, 1.0/16],
                [1.0/8, 1.0/4, 1.0/8],
                [1.0/16, 1.0/8, 1.0/16]];

            // 임시 입력 배열 (입력배열 + 2)
            let tmpInImage = new Array(3);

            for(let m = 0 ; m < 3 ; m++) {
                tmpInImage[m] = new Array(inH+2);

                for(let n = 0 ; n < inH + 2 ; n++) {
                    tmpInImage[m][n] = new Array(inW+2);

                }
            }
            

            // 임시 출력 배열 (출력배열과 크기 동일)
            let tmpOutImage = new Array(3);

            for(let m = 0 ; m < 3 ; m++) {
                tmpOutImage[m] = new Array(outH+2);

                for(let n = 0 ; n < inH + 2 ; n++) {
                    tmpOutImage[m][n] = new Array(outW+2);

                }
            }

            // 임시 입력 배열 초기화 ((127로)/평균값/인접값)
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH + 2 ; i++) {
                    for (let k = 0 ; k < inW + 2 ; k++) {
                        tmpInImage[rgb][i][k] = 127.0;

                    }
                }
            }

            // 입력 이미지 -> 임시 입력 이미지의 중간에 넣기
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k = 0 ; k < inW ; k++) {
                        tmpInImage[rgb][i+1][k+1] = inImage[rgb][i][k];

                    }
                }
            }

            // 영상 처리 알고리즘 --> 회선 연산(=긁어가기)
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < inH ; i++) {
                    for (let k = 0 ; k < inW ; k++) {
                        // 한점 처리
                        let S = 0.0; // 9점을 곱해서 합한 결과

                        for(let m = 0 ; m < 3 ; m++) {
                            for(let n = 0 ; n < 3 ; n++) {
                                S += tmpInImage[rgb][i+m][k+n] * mask[m][n];

                            }  
                        }
                        tmpOutImage[rgb][i][k] = S;

                    }
                }
            }

            // 임시 출력 이미지 --> 원 출력 이미지
            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for (let i = 0 ; i < outH ; i++) {
                    for (let k = 0 ; k < outW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            if(tmpOutImage[rgb][i][k] > 255.0) {
                                outImage[rgb][i][k] = 255;

                            }else if(tmpOutImage[rgb][i][k] < 0.0) {
                                outImage[rgb][i][k] = 0;

                            }else {
                                outImage[rgb][i][k] = parseInt(tmpOutImage[rgb][i][k]);

                            }
                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        // 히스토그램 처리

        function stretchImage() { // 스트레칭 알고리즘
            outH = inH;
            outW = inW;

            outImage = new Array(3); // 3면

                for(let m = 0 ; m < 3 ; m++) {
                    outImage[m] = new Array(outH);

                    for(let n = 0 ; n < outH ; n++) {
                        outImage[m][n] = new Array(outW);

                    }
                }

            let LOW = inImage[0][0][0], HIGH = inImage[0][0][0];

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if(LOW > inImage[rgb][i][k]) {
                            LOW = inImage[rgb][i][k];

                        }

                        if(HIGH<inImage[rgb][i][k]) {
                            HIGH = inImage[rgb][i][k];

                        }
                    }
                }
            }

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            let out = (inImage[rgb][i][k] - LOW) / (HIGH - LOW) * 255.0;

                            if(out < 0.0) {
                                out = 0;

                            }else if(out > 255.0) {
                                out = 255;

                            }else {
                                out = parseInt(out);

                            }
                            outImage[rgb][i][k] = out;

                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            displayImage();

            }
        }

        function endinImage() { // 엔드-인 알고리즘
            outH = inH;
            outW = inW;

            outImage = new Array(3); // 3면
        
            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            let LOW = inImage[0][0][0], HIGH = inImage[0][0][0];

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if(LOW > inImage[rgb][i][k]) {
                            LOW = inImage[rgb][i][k];
                        }

                        if(HIGH < inImage[rgb][i][k]) {
                            HIGH = inImage[rgb][i][k];

                        }
                    }
                }
            }

            LOW += 50;
            HIGH -= 50;

            for(let rgb = 0 ; rgb < 3 ; rgb++) {
                for(let i = 0 ; i < inH ; i++) {
                    for(let k = 0 ; k < inW ; k++) {
                        if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                            let out = (inImage[rgb][i][k] - LOW)/(HIGH - LOW) * 255.0;

                            if(out < 0.0) {
                                out =0;

                            }else if(out>255.0) {
                                out = 255;

                            }else {
                                out = parseInt(out);

                            }
                            outImage[rgb][i][k] = out;

                        }else {
                            outImage[rgb][i][k] = inImage[rgb][i][k];

                        }
                    }
                }
            }
            displayImage();

        }

        function equalizeImage() { // 평활화 알고리즘
            outH = inH;
            outW = inW;

            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            let histoR = new Array(256);
            let histoG = new Array(256);
            let histoB = new Array(256);

            for(let i = 0 ; i < 256 ; i++) {
                histoR[i] = 0;
                histoG[i] = 0;
                histoB[i] = 0;

            }

            for(let i = 0 ; i < inH ; i++) {
                for(let k = 0 ; k < inW ; k++) {
                    histoR[inImage[0][i][k]]++;
                    histoG[inImage[1][i][k]]++;
                    histoB[inImage[2][i][k]]++;

                }
            }

            let sumHistoR = new Array(256);
            let sumHistoG = new Array(256);
            let sumHistoB = new Array(256);

            for(let i = 0 ; i < 256 ; i++) {
                sumHistoR[i] = 0;
                sumHistoG[i] = 0;
                sumHistoB[i] = 0;

            }

            let sumValueR = 0;
            let sumValueG = 0;
            let sumValueB = 0;

            for(let i = 0 ; i < 256 ; i++) {
                sumValueR += histoR[i];
                sumHistoR[i] = sumValueR;

                sumValueG += histoG[i];
                sumHistoG[i] = sumValueG;

                sumValueB += histoB[i];
                sumHistoB[i] = sumValueB;

            }

            let nomalHistoR = new Array(256);
            let nomalHistoG = new Array(256);
            let nomalHistoB = new Array(256);

            for(let i = 0 ; i < 256 ; i++) {
                nomalHistoR[i] = 0.0;
                nomalHistoG[i] = 0.0;
                nomalHistoB[i] = 0.0;

            }

            for(let i = 0 ; i < 256 ; i++) {
                let nomalR = sumHistoR[i] * (1.0 / (inH * inW)) * 255.0;
                nomalHistoR[i] = nomalR;
                let nomalG = sumHistoG[i] * (1.0 / (inH * inW)) * 255.0;
                nomalHistoG[i] = nomalG;
                let nomalB = sumHistoB[i] * (1.0 / (inH * inW)) * 255.0;
                nomalHistoB[i] = nomalB;

            }

            for(let i = 0 ; i < inH ; i++) {
                for(let k = 0 ; k < inW ; k++) {
                    if((startX <= k && k <= endX ) && (startY <= i && i <= endY)) {
                        outImage[0][i][k] = parseInt(nomalHistoR[inImage[0][i][k]]);
                        outImage[1][i][k] = parseInt(nomalHistoG[inImage[1][i][k]]);
                        outImage[2][i][k] = parseInt(nomalHistoB[inImage[2][i][k]]);

                    }else {
                        outImage[0][i][k] = inImage[0][i][k];
                        outImage[1][i][k] = inImage[1][i][k];
                        outImage[2][i][k] = inImage[2][i][k];

                    }
                }
            }
            displayImage();

        }

        // 채도 변환 처리

        function brightImage() { // 명도 변환 알고리즘
            // (중요!) 출력 이미지의 크기가 결정 ---> 알고리즘에 의존...
            outH = inH;
            outW = inW;

            // 출력 영상의 3차원 메모리 할당
            outImage = new Array(3); // 3면

            for(let m = 0 ; m < 3 ; m++) {
                outImage[m] = new Array(outH);

                for(let n = 0 ; n < outH ; n++) {
                    outImage[m][n] = new Array(outW);

                }
            }

            // **** 진짜 영상처리 알고리즘 *****
            let v_value = parseFloat(prompt("숫자 입력(0~1)", "-0.2"));

            for (let i = 0 ; i < inH ; i++) {
                for (let k = 0 ; k < inW ; k++) {
                    if((startX <= k && k < endX) && (startY <= i && i < endY)) {
                        let R = inImage[0][i][k];
                        let G = inImage[1][i][k];
                        let B = inImage[2][i][k];

                        /// RGB --> HSV
                        let hsv = rgb2hsv(R,G,B); // { h:0~360, s:0~1.0, v:0~1.0 }
                        let H = hsv.h;
                        let S = hsv.s;
                        let V = hsv.v;

                        //채도를 변경
                        V = V + v_value;

                        //HSV --> RGB
                        let rgb = hsv2rgb(H, S, V);
                        R = rgb.r;
                        G = rgb.g;
                        B = rgb.b;

                        // 출력 영상에 넣기
                        outImage[0][i][k] = R;
                        outImage[1][i][k] = G;
                        outImage[2][i][k] = B;

                    }else {
                        outImage[0][i][k] = inImage[0][i][k];
                        outImage[1][i][k] = inImage[1][i][k];
                        outImage[2][i][k] = inImage[2][i][k];

                    }

                }
            }
            displayImage();

        }



        // 마우스 처리 공통 함수 //

        // 마우스 처리 부분
        let startX, startY, endX, endY;
        let pressYN = false;
        let imageData; // 마우스 클릭 시점의 화면
        let algoValue;

        function inAlgoValue(alvalue) {
            algoValue = alvalue;
            
            // 화소점 처리

            if(algoValue == "영상 반전") {
                reverseImage_mouse();
            }
            if(algoValue == "영상 반전(마우스)") {
                reverseImage_mouse();
            }
            if(algoValue == "그레이 스케일") {
                grayImage_mouse();
            }
            if(algoValue == "그레이 스케일(마우스)") {
                grayImage_mouse();
            }
            if (algoValue == "흑백 처리") {
                bwImage_mouse();
            }
            if (algoValue == "흑백(마우스)") {
                bwImage_mouse();
            }
            if (algoValue == "흑백(평균)") {
                avgbwImage_mouse();
            }
            if (algoValue == "흑백(평균)(마우스)" ) {
                avgbwImage_mouse();
            }
            if (algoValue == "밝기 조절") {
                addImage_mouse();
            }
            if (algoValue == "밝기 조절(마우스)" ) {
                addImage_mouse();
            }
            if (algoValue == "곱하기") {
                mulImage_mouse();
            }
            if (algoValue == "곱하기(마우스)" ) {
                mulImage_mouse();
            }
            if (algoValue == "나누기") {
                divImage_mouse();
            }
            if (algoValue == "나누기(마우스)" ) {
                divImage_mouse();
            }
            if (algoValue == "감마처리") {
                gammaImage_mouse();
            }
            if (algoValue == "감마처리(마우스)" ) {
                gammaImage_mouse();
            }
            if (algoValue == "파라볼라(Cup)") {
                paracupImage_mouse();
            }
            if (algoValue == "파라볼라(Cup)(마우스)" ) {
                paracupImage_mouse();
            }
            if (algoValue == "파라볼라(Cap)") {
                paracapImage_mouse();
            }
            if (algoValue == "파라볼라(Cap)(마우스)" ) {
                paracapImage_mouse();
            }

            // 히스토 그램 처리

            if (algoValue == "스트레칭") {
                stretchImage_mouse();
            }
            if (algoValue == "스트레칭(마우스)" ) {
                stretchImage_mouse();
            }
            if (algoValue == "엔드-인") {
                endinImage_mouse();
            }
            if (algoValue == "엔드-인(마우스)" ) {
                endinImage_mouse();
            }
            if (algoValue == "평활화") {
                equalizeImage_mouse();
            }
            if (algoValue == "평활화(마우스)" ) {
                equalizeImage_mouse();
            }

            // 기하학 처리

            if (algoValue == "상하미러링") {
                udImage_mouse();
            }
            if (algoValue == "상하미러링(마우스)" ) {
                udImage_mouse();
            }
            if (algoValue == "좌우미러링") {
                lrImage_mouse();
            }
            if (algoValue == "좌우미러링(마우스)" ) {
                lrImage_mouse();
            }
            if (algoValue == "축소") {
                zoomoutImage_mouse();
            }
            if (algoValue == "축소(마우스)" ) {
                zoomoutImage_mouse();
            }
            if (algoValue == "확대(포워딩)") {
                zoominImage_mouse();
            }
            if (algoValue == "확대(포워딩)(마우스)" ) {
                zoominImage_mouse();
            }
            if (algoValue == "확대(백워딩)") {
                zoominImage2_mouse();
            }
            if (algoValue == "확대(백워딩)(마우스)" ) {
                zoominImage2_mouse();
            }
            if (algoValue == "사진이동") {
                moveImage_mouse();
            }
            if (algoValue == "사진이동(마우스)") {
                moveImage_mouse();
            }
            if (algoValue == "회전") {
                rotateImage_mouse();
            }
            if (algoValue == "회전(마우스)") {
                rotateImage_mouse();
            }
            if (algoValue == "회전(nocut)") {
                rotateImage_mouse();
            }
            if (algoValue == "회전(nocut)(마우스)") {
                ncrotateImage_mouse();
            }

            // 화소영역 처리
        
            if (algoValue == "엠보싱") {
                embossImage_mouse();
            }
            if (algoValue == "엠보싱(마우스)" ) {
                embossImage_mouse();
            }
            if (algoValue == "블러링") {
                blurImage_mouse();
            }
            if (algoValue == "블러링(마우스)" ) {
                blurImage_mouse();
            }
            if (algoValue == "가우시안") {
                gaussianImage_mouse();
            }
            if (algoValue == "가우시안(마우스)" ) {
                gaussianImage_mouse();
            }
            if (algoValue == "샤프닝") {
                sharpeImage_mouse();
            }
            if (algoValue == "샤프닝(마우스)" ) {
                sharpeImage_mouse();
            }

            // 화소영역 처리

            if (algoValue == "채도변경") {
                brightImage_mouse();
            }
            if (algoValue == "채도변경(마우스)") {
                brightImage_mouse();
            }

        }

        function __downMouse(event) {
            startX = event.offsetX;
            startY = event.offsetY;
            pressYN = true;

            // 현재 상태를 보관하기
            imageData = inCtx.getImageData(0, 0, inCanvas.width, inCanvas.height);

        }

        function __upMouse(event) {
            inCtx.putImageData(imageData, 0, 0);
            endX = event.offsetX;
            endY = event.offsetY;

            // 선택한 네모 박스 안쪽만 영상처리 되기
            // 시작과 끝을 재배치 
            if (startX > endX) {
                let tmp = startX;
                startX = endX;
                endX = tmp;
                
            }

            if (startY > endY) {
                let tmp = startY;
                startY = endY;
                endY = tmp;

            }

            // 마우스 이벤트 리스너 끄기
            inCanvas.removeEventListener("mousedown", __downMouse, false);
            inCanvas.removeEventListener("mouseup", __upMouse, false);
            inCanvas.removeEventListener("mousemove", __moveMouse, false);

            pressYN = false;

            if (algoValue == "영상 반전(마우스)") {
                reverseImage();
            }
            if (algoValue == "그레이 스케일(마우스)") {
                grayImage();
            }
            if (algoValue == "흑백(마우스)") {
                bwImage();
            }
            if (algoValue == "흑백(평균)(마우스)") {
                avgbwImage();
            }
            if (algoValue == "밝기 조절(마우스)") {
                addImage();
            }
            if (algoValue == "곱하기(마우스)" ) {
                mulImage();
            }
            if (algoValue == "나누기(마우스)" ) {
                divImage();
            }
            if (algoValue == "감마처리(마우스)" ) {
                gammaImage();
            }
            if (algoValue == "파라볼라(Cup)(마우스)" ) {
                paracupImage();
            }
            if (algoValue == "파라볼라(Cap)(마우스)" ) {
                paracapImage();
            }
            if (algoValue == "스트레칭(마우스)" ) {
                stretchImage();
            }
            if (algoValue == "엔드-인(마우스)" ) {
                endinImage();
            }
            if (algoValue == "평활화(마우스)" ) {
                equalizeImage();
            }
            if (algoValue == "엠보싱(마우스)" ) {
                embossImage();
            }
            if (algoValue == "블러링(마우스)" ) {
                blurImage();
            }
            if (algoValue == "가우시안(마우스)" ) {
                gaussianImage();
            }
            if (algoValue == "샤프닝(마우스)" ) {
                sharpeImage();
            }
            if (algoValue == "상하미러링(마우스)" ) {
                udImage();
            }
            if (algoValue == "좌우미러링(마우스)" ) {
                lrImage();
            }
            if (algoValue == "축소(마우스)" ) {
                zoomoutImage();
            }
            if (algoValue == "확대(포워딩)(마우스)" ) {
                zoominImage();
            }
            if (algoValue == "확대(백워딩)(마우스)" ) {
                zoominImage2();
            }
            if (algoValue == "사진이동(마우스)") {
                moveImage();
            }
            if (algoValue == "회전(마우스)") {
                rotateImage();
            }
            if (algoValue == "회전(nocut)(마우스)") {
                ncrotateImage();
            }
            if (algoValue == "채도변경(마우스)") {
                brightImage();
            }
        }

        function __moveMouse(event) {
            if(!pressYN) {
                return;
            }
            
            inCtx.putImageData(imageData, 0, 0);

            endX = event.offsetX;
            endY = event.offsetY;

            inCtx.beginPath(); // 선그리기 시작
            inCtx.strokeStyle = 'Red';
            inCtx.lineWidth = 1;

            inCtx.rect(startX, startY, (endX - startX), (endY - startY));

            inCtx.stroke();
            inCtx.closePath(); // 선그리기 끝

        }

        // 마우스 처리 공통 함수 -//

        // 영상처리 메뉴 호출 함수 //

        function onEventListener() { // 마우스 이벤트 리스너 켜기
            inCanvas.addEventListener("mousedown", __downMouse, false);
            inCanvas.addEventListener("mouseup", __upMouse, false);
            inCanvas.addEventListener("mousemove", __moveMouse, false);
        }

        function reverseImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;
                
                reverseImage();

                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()

        }

        function grayImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                grayImage();

                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()

        }

        function bwImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                bwImage();

                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function avgbwImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                avgbwImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function addImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                addImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function mulImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                mulImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }
        
        function divImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                divImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function gammaImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                gammaImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function paracupImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                paracupImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function paracapImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                paracapImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function stretchImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                stretchImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function endinImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                endinImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function equalizeImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                equalizeImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function embossImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                embossImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function blurImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                blurImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function gaussianImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                gaussianImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function sharpeImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                sharpeImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function udImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                udImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function lrImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                lrImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function zoomoutImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                zoomoutImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function zoominImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                zoominImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function zoominImage2_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                zoominImage2();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function moveImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                moveImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function rotateImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                rotateImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function ncrotateImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                ncrotateImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }

        function brightImage_mouse() {
            // 사각형 선택이 체크가 안되었을 때!
            let mouseEnable = document.getElementById("mouseEnable");

            if (!mouseEnable.checked) {
                startX = startY = 0;
                endX = inW;
                endY = inH;

                brightImage();
                
                return;
            }

            // 사각형 체크 됨.
            // 마우스 이벤트 리스너 켜기
            onEventListener()
        }


        // ** RGB TO HSV **////
        // ** HSV TO RGB ** ///

        function rgb2hsv(r, g, b) {
            let max = Math.max(r, g, b),
            min = Math.min(r, g, b),
            d = max - min,
            h,
            s = max === 0 ? 0 : d / max,
            v = max / 255;

            switch(max) {
                case min :
                    h = 0;
                    break;
                    
                case r :
                    h = g - b + d * (g < b ? 6 : 0);
                    h /= 6 * d;
                    break;

                case g :
                    h = b - r + d * 2;
                    h /= 6 * d;
                    break;

                case b :
                    h = r - g + d * 4;
                    h /= 6 * d;
                    break;

                }

                return {
                    h: h,
                    s: s,
                    v: v,

            };
        }

        function hsv2rgb(h, s, v) {
            let r, g, b, i, f, p, q, t;

            h = h * 360;
            s = s * 100;
            v = v * 100;

            h = Math.max(0, Math.min(360, h));
            s = Math.max(0, Math.min(100, s));
            v = Math.max(0, Math.min(100, v));

            h /= 360;
            s /= 100;
            v /= 100;

            i = Math.floor(h * 6);
            f = h * 6 - i;
            p = v * (1 - s);
            q = v * (1 - f * s);
            t = v * (1 - (1 - f) * s);

            switch (i % 6) {
                case 0 :
                    (r = v), (g = t), (b = p);
                    break;

                case 1 :
                    (r = q), (g = v), (b = p);
                    break;

                case 2 :
                    (r = p), (g = v), (b = t);
                    break;

                case 3 :
                    (r = p), (g = q), (b = v);
                    break;

                case 4 :
                    (r = t), (g = p), (b = v);
                    break;

                case 5 :
                    (r = v), (g = p), (b = q);
                    break;

            }

            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255),
                
            };
        }


    </script>
    
    </head>

    <body onload="init()">
        <header>
            <div style="text-align:center">
                <h1> 영상 처리 프로그램 (GA, RTM, 1.0) </h1>
            </div>
        </header>

        <form>
            <div id = "box" style = "text-align:left; border: 3px solid skyblue; border-radius: 15px; padding: 3px; border-radius: 8px;">
                <section>
                    <input type="checkbox" id="mouseEnable"> 사각형범위 부분영상처리 <br>
                    <input type="number" id="fileNum" >
                    <input type="button" id="inFile" value="이미지 열기" onclick="openImage()">
                </section>
            </div>
            <br>

            <nav id="Lnav">
                <div style="text-align:center">
                    <hr>
                    <div id = "pixel"> * 화소점 처리 * </div>
                    <hr>

                    <div id = "button1"><input type = "button" id = "equalImage1" class = "button" value = "동일 영상" onclick = "equalImage()"></div>
                    <div id = "button1"><input type = "button" id = "reverseImage1" class = "button" value = "영상 반전" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "grayImage1" class = "button" value = "그레이 스케일" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "bwImage1" class = "button" value = "흑백 처리" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "avgbwImage1" class = "button" value = "흑백(평균)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "addImage1" class = "button" value = "밝기 조절" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "mulImage1" class = "button" value = "곱하기" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "divImage1" class = "button" value = "나누기" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "gammaImage1" class = "button" value = "감마처리" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "paracupImage1" class = "button" value = "파라볼라(Cup)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "paracapImage1" class = "button" value = "파라볼라(Cap)" onclick = "inAlgoValue(this.value)"></div>
                    
                    <hr>  
                    <div id = "pixel"> * 히스토그램 처리 * </div>
                    <hr>

                    <div id = "button1"><input type = "button" id = "stretchImage1" class = "button" value = "스트레칭" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "endinImage1" class = "button" value = "엔드-인" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "equalizeImage1" class = "button" value = "평활화" onclick = "inAlgoValue(this.value)"></div>

                </div>
            </nav>

            <nav id="Lnav">
                <div style="text-align:center">
                    <hr>
                    <div id = "pixel"> *화소점 처리(마우스)* </div>
                    <hr>
                    <div id = "button1"><input type = "button" id = "reverseImage_mouse1" class = "button" value = "영상 반전(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "grayImage_mouse1" class = "button" value = "그레이 스케일(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "bwImage_mouse1" class = "button" value = "흑백(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "avgbwImage1" class = "button" value = "흑백(평균)(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "addImage1" class = "button" value = "밝기 조절(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "mulImage1" class = "button" value = "곱하기(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "divImage1" class = "button" value = "나누기(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "gammaImage1" class = "button" value = "감마처리(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "paracupImage1" class = "button" value = "파라볼라(Cup)(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "paracapImage1" class = "button" value = "파라볼라(Cap)(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    
                    <hr>
                    <div id = "pixel"> * 히스토그램 처리 * </div>
                    <hr>

                    <div id = "button1"><input type = "button" id = "stretchImage1" class = "button" value = "스트레칭(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "endinImage1" class = "button" value = "엔드-인(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "equalizeImage1" class = "button" value = "평활화(마우스)" onclick = "inAlgoValue(this.value)"></div>

                </div>
            </nav>

            <nav id="Rnav">
                <div style="text-align:center">
                    <hr>
                    <div id = "pixel"> * 기하학 처리 * </div>
                    <hr>

                    <div id = "button1"><input type = "button" id = "udImage1" class = "button" value = "상하미러링" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "lrImage1" class = "button" value = "좌우미러링" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "zoomoutImage1" class = "button" value = "축소" onclick = "inAlgoValue(this.value)"></div>

                    <div id = "button1"><input type = "button" id = "zoominImage1" class = "button" value = "확대(포워딩)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "zoominImage_2" class = "button" value = "확대(백워딩)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "moveImage1" class = "button" value = "사진이동" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "rotateImage1" class = "button" value = "회전" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "ncrotateImage1" class = "button" value = "회전(nocut)" onclick = "inAlgoValue(this.value)"></div>
                    
                    <hr>
                    <div id = "pixel"> * 화소영역 처리 * </div>
                    <hr>
                    <div id = "button1"><input type = "button" id = "embossImage1" class = "button" value = "엠보싱" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "blurrImage1" class = "button" value = "블러링" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "gaussianImage1" class = "button" value = "가우시안" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "sharpeImage1" class = "button" value = "샤프닝" onclick = "inAlgoValue(this.value)"></div>
                    
                    <hr>
                    <div id = "pixel"> * 채도 변환 * </div>
                    <hr>
                    <div id = "button1"><input type = "button" id = "brightImage1" class = "button" value = "채도변경" onclick = "inAlgoValue(this.value)"></div>

                    </select>
                </div>
            </nav>

            <nav id="Rnav">
                <div style="text-align:center">
                    <hr>
                    <div id = "pixel"> * 기하학 처리(마우스) * </div>
                    <hr>

                    <div id = "button1"><input type = "button" id = "udImage1" class = "button" value = "상하미러링(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "lrImage1" class = "button" value = "좌우미러링(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "zoomoutImage1" class = "button" value = "축소(마우스)" onclick = "inAlgoValue(this.value)"></div>

                    <div id = "button1"><input type = "button" id = "zoominImage1" class = "button" value = "확대(포워딩)(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "zoominImage_2" class = "button" value = "확대(백워딩)(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "moveImage1" class = "button" value = "사진이동(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "rotateImage1" class = "button" value = "회전(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "ncrotateImage1" class = "button" value = "회전(nocut)(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    
                    <hr>
                    <div id = "pixel"> * 화소영역 처리 * </div>
                    <hr>
                    <div id = "button1"><input type = "button" id = "embossImage1" class = "button" value = "엠보싱(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "blurrImage1" class = "button" value = "블러링(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "gaussianImage1" class = "button" value = "가우시안(마우스)" onclick = "inAlgoValue(this.value)"></div>
                    <div id = "button1"><input type = "button" id = "sharpeImage1" class = "button" value = "샤프닝(마우스)" onclick = "inAlgoValue(this.value)"></div>

                    <hr>
                    <div id = "pixel"> * 채도 변환 * </div>
                    <hr>
                    <div id = "button1"><input type = "button" id = "brightImage1" class = "button" value = "채도변경(마우스)" onclick = "inAlgoValue(this.value)"></div>




                    </select>
                </div>
            </nav>

        </form>
        <br>

        <section>
        <div style="text-align:center">
            <div id = in_canvas>
                <canvas id="inCanvas" style="background-color:rgb(0, 0, 0)"></canvas>
                <h3>Before</h3>
            </div>

            <div id="out_canvas">
                <canvas id="outCanvas" style="background-color:rgb(0, 0, 0)"></canvas>
                <h3>After</h3>
            </div>
        </div>
        </section>

    </body>
</html>